[{"categories":null,"contents":"   同步任务  因为 JavaScript 是单线程的，所以同步任务只能在主线程上排队执行，并且只有当前一个任务完成才能执行下一个任务\n当 JavaScript 运行时，每个函数的执行都会进入调用栈（Call Stack）中，当前函数执行完毕后将其移出栈，然后执行下一个函数，如果其中有非常耗时的函数执行，那么调用栈就阻塞了，后面的任务只能一直处于等待状态无法执行，且此时 UI 对面任何用户操作都不会响应，看起来就像程序崩溃了一样。\n为什么解决这个问题，我们有了异步任务\n   异步任务  常见的异步：\n setTimeout() setInterval() Promise.resolve().then() fetch.then()  异步任务在执行之前不会进入调用栈，它进入事件循环队列（Event Loop Queue），当主线程执行完毕后，且异步时机到了，就会将事件循环队列中的任务推入调用栈中执行。\n   Event Loop  Event Loop 的工作非常简单，它只是监控调用栈和回调队列（包含每个事件对应的回调函数，比如 click 的回调函数）。如果调用栈为空，Event Loop 将队列中的第一个任务移除并推送到调用栈。\n从 ES6 开始，Event Loop 处理异步也分两种，在Macrotask中处理setTimeout这类的，在Microtask中处理Promise这类的。它会优先处理Microtask中的任务\n   Node.js 中的 Event Loop  Node.js 中的 Event Loop 分为 6 个阶段，依次是：\n timers 定时器  这个阶段执行已被setTimeout()和setInterval()调度的回调函数   pending callbacks 待定回调  执行延迟到下一个循环迭代的I/O回调   idle, prepare  Node.js 系统内部使用   poll 轮询  检索新的 I/O 事件；执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞（等待）   check 检测  setImmediate()回调函数在这里执行   close callback 关闭的回调函数  一些关闭的回调函数，如：sockt.on('close', ...)    process.nextTick()的回调会在每个阶段结束之前调用。\n每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。\n当我们在 Node 中首次执行 JavaScript 代码时，会有开启 Event Loop 和执行 JavaScript 两个阶段，这两个阶段是串行发生，开启速度受制于机器性能，这就是为什么在主线程中执行这两个异步，他们的顺序并不总是相同。\n   Promise  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const fn = (resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ info: \u0026#39;success\u0026#39; }) }, 3000) } const promise = new Promise(fn) const onFulfilled = (data) =\u0026gt; { console.log(data) } const onRejected = (reson) =\u0026gt; { console.log(reason) } promise.then(onFulfilled, onRejected)   上面的代码是一个基本的Promise使用方法，对于Promise的学习，个人认为直接看 A+ 规范比较好，接下来我会基于 A+ 规范的角度来详细介绍 Promise。\nPromise表示构造函数，promise表示实例化对象。\n  Promise是一个构造函数，接受一个回调函数作为参数，这个参数必须是函数，否则抛出TypeError\n  promise具有三种状态：pending、fulfilled、rejected，\n 当状态转换至fulfilled或rejected时，状态不可再次变更，且fulfilled状态必须有一个值（不可变），rejected状态必须有一个值作为拒绝的原因（不可变）    promise必须具有then方法，用来访问当前值，或最终值，或被拒绝的原因\n then方法接受两个参数，如上面代码所示onFulfilled和onRejected 这两个参数都是可选的，且如果其不是函数，则必须被忽略    onFulfilled如果是函数，则会在promise已经是fulfilled状态时调用，且将promise的值作为第一个参数，该函数只被调用一次\n  onRejected如果是函数，则会在promise已经是rejected状态时调用，且将promise拒绝的原因作为第一个参数，该函数只被调用一次\n  在执行上下文堆栈仅包含平台代码之前，不得调用 onFulfilled 或 onRejected\n 这句话的意思其实就是将onFulfilled/onRejected添加到Microtask队列中去，异步调用它    onFulfilled/onRejected作为函数调用时，其内部没有this\n  then可以在同一个promise上多次调用\n1 2 3 4 5 6 7  const promise = Promise.resolve(\u0026#39;success\u0026#39;) promise.then(..., ...) promise.then(..., ...) promise.then(..., ...) // onFulfilled/onRejected 必须按照书写顺序执行     then必须新建且返回一个promise\n1 2 3 4 5  const promise = Promise.resolve(\u0026#39;success\u0026#39;) const promise2 = promise.then(onFulfilled, onRejected) promise2 instanceof Promise //true    如果 onFulfilled 或 onRejected 抛出异常 e, promise2 必须被拒绝，并把 e 作为被拒绝的原因 如果 onFulfilled 不是函数，且 promise处于已处理状态，则 promise2 也必须处于已处理状态，且拥有和 promise 已处理状态相同的值。 如果 onRejected 不是函数，且 promise 处于已拒绝状态，则 promise2 必须处于已拒绝状态，且拥有和 promise 相同的拒绝原因 2.2.7.1 如果 onFulfilled 或 onRejected 返回值 x，执行Promise解决步骤 [[Resolve]](promise2, x)    在这里引入一下规范中的Promise解决步骤，这里我会直接用白话讲，其代码实现可以参考我的代码\n  Promise解决步骤其实就是Promise中的一个静态私有方法，暂且命名为resolveWith\n  当onFulfilled/onRejected返回值x的时候，就执行resolveWith(promise2, x)，这个promise2在then方法执行时创建\n  执行resolveWith(promise2, x)，它具有以下规则\n  如果promise2和x引用同一个对象，即promise2 === x为true，则以一个TypeError类型的值作为拒绝promise2的原因\n  如果x是一个Promise对象，接收其状态\n1 2 3 4 5 6 7 8  const promise = Promise.resolve(\u0026#39;success\u0026#39;) const result = Promise.resolve(data) cosnt promise2 = promise.then((data) =\u0026gt; { return result //return 了一个 fulfilled 状态的 Promise 对象 }) promise2.state === result.state //true !!!这里的 state 属性实际是不能访问的，这里只是为了演示 promise2.value === result.value //true !!!这里的 value 属性实际是不能访问的，这里只是为了演示    当x处于pending状态时，promise2也必须保持未处理状态，直到x被处理或拒绝 当x处于fulfilled状态时，promise2也必须处于fulfilled状态，且值相同 当x处于rejected状态时，promise2也必须处于rejected状态，且拒绝的原因相同    当x是一个对象或函数时\n  用x.then代替then\n1  const then = x.then     如果在获取x.then的过程中抛出异常e，则拒绝promise2并用e作为拒绝的原因\n 解释以下为什么获取一个对象的属性会抛出异常，Object.defineProperty()可以设置一个属性的getter/setter，可以在getter中抛出异常    如果x.then是一个函数（这时就可以将x视为thenable，因为它具有then方法），则用x作为this调用该函数，并将resolvePromise作为函数的第一个参数，rejectePromise作为函数的第二个参数\n1 2 3 4 5 6  const then = x.then if(then instanceof Function){ then.call(x, resolvePromise, rejectPromise) } // 看懂了吗，就跟我们的 promise.then(onFulfilled, onRejected)一样，只不过改用 call 调用并改变 this 指向     如果/当使用值 y 调用 resolvePromise 时，运行 resolveWith(promise, y)（这里其实就有点递归的味道了，规范也确实提到了这种方法可能会导致无限递归，如果thenable的then方法返回一个thenable2，且thenable2的then也返回一个thenable3···，一直这样套娃，就会无限递归，最后爆栈了）\n  如果/当使用 r 作为原因调用 rejectPromise 时，用 r 拒绝 promise。\n1 2 3 4 5 6 7  if (then instanceof Function) { then.call( this, (y: any) =\u0026gt; { this.resolveWith(y) }, (r: any) =\u0026gt; { this.reject(r) } ) }     上面两句话的意思就是说，x作为thenable，可以定义自己的then方法，且在其中自由决定调用resolve还是reject\n1 2 3 4 5 6 7 8 9  const thenable = { then(resolve, reject){ resolve(1) } } const promise = Promise.resolve(1) const promise2 = promise.then(() =\u0026gt; thenable) //thenable的then方法会在promise的then中被调用     如果同时调用 resolvePromise 和 rejectPromise，或者对同一个参数进行多次调用，则第一次调用优先，并且忽略任何后来的的调用（这里就是onFulfilled和onRejected的特征）\n  如果调用 then 时抛出异常 e\n 如果 resolvePromise 或 rejectPromise 已经被调用，忽略该异常 否则，拒绝 promise2 并以 e 作为拒绝原因    如果 then 不是函数，用 x 去执行 promise2\n    如果 x 不是对象或函数，用 x 去执行 promise2\n      上述的Promise解决步骤，用白话来说就是\n 如果onFulfilled或onRejected返回的x是一个简单数据类型，那么then方法就返回一个处于onFulfilled的新的promise，且值是x 如果onFulfilled或onRejected返回的x是一个函数或对象（其实函数也是一种对象啦），则判断x是否具有then方法（或者说判断x是否是一个thenable)  如果x.then是一个函数，则取执行它，且它内部的this还是x，且x.then接受两个参数：resolve和reject，x.then调用resolve/reject，那么promise2也会是对应的状态，且值就是x.then调用resolve/reject所传的值      至此，A+ 规范就结束了，A+ 规范定义了Promise的基本行为和Promise链的实现\n  A+ 译文参考\n以下内容待更新\n promise.catch() promise.finally() Promise.race() Promise.all() Promise.allSettled() Promise.any() Promise.resolve/reject() async/await  ","date":"Feb 11","permalink":"https://zinkwu.blog/articles/event-loop-promise-async-await/","tags":["javascript"],"title":"Event Loop Promise async/await 总结"},{"categories":null,"contents":"要理解继承，首先需要理解原型链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Person(name, age, gender){ this.name = name this.age = age this.gender = gender } Person.prototype.hi = function (){ console.log(`Hi, I\u0026#39;m ${this.name}`) } let f = new Person(\u0026#39;zoe\u0026#39;, 18, \u0026#39;female\u0026#39;) f.__proto__ === Person.prototype // true，ES5写法 Object.getPrototypeOf(f) === Person.prototype // true，ES6写法, __proto__ 是浏览器厂商私建 Person.prototype.__proto__ === Object.prototype // true   首先定义几个基本名词：\n 实例对象：通过new xxx出来的对象叫做实例对象 构造函数：如上方代码中的Person，一般以大写字母开头命名 - __proto__：ES6 之前，没有明确访问原型的方法，只能通过__proto__来访问，它的作用就是找到实例对象的原型 prototype：原型，是构造函数的一个属性 constructor：构造函数，写过 Java 这类 oop 的同学应该不陌生，这个在 ES5 中不经常接触到，ES6 中的 Class 经常用到，  然后通过上面的代码，我们可以得到这样的公式：\n实例对象.__proto__ === 构造函数.prototype 构造函数.prototype.__proto__ === Object.prototype （长继承不适用，这里的继承链是 Person 继承 Object） 其次，Object 是原型链的顶端 Object.prototype.__proto__ === null ok，那么明白了这个，我们就来讨论继承，继承本质上只是用来减少重复代码的一种编程手段，如果我们有多个类，并且都有重复的属性，那么我们可以将重复的属性提取到父类身上，再由父类通过继承给子类。再简化一下：子类构造函数的实例对象也能访问到父类的属性或方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Male(name, age){ this.name = name this.age = age this.gender = \u0026#39;male\u0026#39; } let m = new Male(\u0026#34;m\u0026#34;, 24) function Female(name, age){ this.name = name this.age = age this.gender = \u0026#39;female\u0026#39; } let f = new Female(\u0026#34;f\u0026#34;, 24)   在上面这个例子中，我们定义了两个构造函数，分别来构造男性和女性，但是 name 和 age 重复了，此时我们可以创建一个父类，来优化掉重复的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function Human(name, age){ this.name = name this.age = age } Human.prototype.sayHi = function (){ console.log(`Hi, I\u0026#39;m ${this.name}, ${this.name}years old`) } // ok，有父类了，接下来考虑如何继承  function Male(name, age){ // 父类实例化对象的属性我也得有 \tHuman.call(this, name, age) this.gender = \u0026#39;male\u0026#39; } // 还得能访问到父类原型上的方法 Male.prototype = Object.create(Human.prototype) //Object.create 创建一个新的对象，新对象的 __proto__ 指向参数对象 Male.prototype.constructor === Male // 上一步中构造函数被 Human 覆盖掉了，这里改回来  // 到这里就结束了，Male 的 prototype 是一个空对象，并且 prototype 的 __proto__ 指向了 Human 的 prototype // 其实 ES6 Class 的继承 extends 也是做了和上面两行代码相同的事  let m = new Male(\u0026#34;zink\u0026#34;, 24) m.sayHi() // sayHi是 Human 原型上的方法 console.log(m) // Male {name: \u0026#39;zink\u0026#39;, age: 24, gender: \u0026#39;male\u0026#39;}   ","date":"Feb 10","permalink":"https://zinkwu.blog/articles/whats-inheritance/","tags":["javascript"],"title":"什么是继承？"},{"categories":null,"contents":"曾经遇到过很多喜欢谈论宏大叙事的人，总是把政策、国情之类话题挂在嘴边但又并不是相关学术研究者的人，而谈论这些的目的，是在寻找何处有利可图，何处可以投机。\n但在我看来，如今任何一个国家都无法构成单一的经济体，现在我们面临的是一个更为复杂、多元、全球性的经济体，换而言之，影响个人命运的变量越来越多，无法由自己掌握的东西太多，在过去的中国，社会情绪是只要努力就能成功，996 之类的东西无所谓，因为这个承诺最后大概率是能兑现的，而今天的社会情绪变为了内卷和躺平，反对 996 的社会情绪让更多人意识到：不管你如何努力工作，最后这所谓成功的承诺大概率是实现不了的。随着媒体的不断炒作，这种无力感、失控感越来越强。而谈论、研究政策之类的东西，会让人产生一种虚幻的权力感，让人觉得自己的思想凌驾于他人之上，并非凡人，他们需要在自己的圈子里重复此类话题的谈论，不断强化这虚幻的权力感，借此摆脱那种无力感。\n","date":"Jan 25","permalink":"https://zinkwu.blog/articles/people-talking-about-grand-narratives/","tags":["随想"],"title":"谈论宏大叙事的人们"},{"categories":["Vue3"],"contents":"好记性不如烂笔头\n   Basic     通过 createApp 创建应用实例  在 vue2.x 中，使用的是new Vue()，返回的是根组件实例，而createApp返回的是应用实例，想要得到根组件实例，还需要使用mount方法，个人认为这个改动是在语法层面上区分创建组件和创建应用\n   ES6 Proxy  vue2.x 使用 Object.defineProperty来实现数据相应，vue3 中使用 new Proxy()为数据架设一层代理，来实现数据响应\n   计算属性 computed   计算属性会缓存结果，只要依赖值不变，多次访问该计算属性也不会执行代码，而是直接返回缓存结果，减小性能开销 计算属性拥有getter、setter     侦听器 watch   watch 与 computed 几乎相同，唯一不同的是，watch 允许在其中执行异步操作     class 与 style 的绑定     class    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;div :class=\u0026#34;{active: isActive}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;classes\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; data(){ return { classes: { avtive: true, container: true } } } \u0026lt;div :class=\u0026#34;[activeClass, containerClass]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; data(){ return { activeClass: \u0026#39;active\u0026#39;, containerClass: \u0026#39;container\u0026#39; } }     也可以直接在v-bind:class中使用三运运算符来切换 class\n  在自定义组件上使用 class\n  若组件内只有一个根元素，那么这些 class 会自动合并在根元素上\n  若有多个根元素，需要定义哪些根元素接收 class，使用$attrs\n  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component class=\u0026#34;baz\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; const app = Vue.createApp({}) app.component(\u0026#39;my-component\u0026#39;, { template: ` \u0026lt;p :class=\u0026#34;$attrs.class\u0026#34;\u0026gt;Hi!\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;This is a child component\u0026lt;/span\u0026gt; ` })       继承的 Attribute 可以使用$arrts来定义 Attribute 具体出现在哪个元素上\n  1 2 3 4 5 6 7 8 9 10  app.component(\u0026#39;date-picker\u0026#39;, { inheritAttrs: false, template: ` \u0026lt;div class=\u0026#34;date-picker\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;datetime-local\u0026#34; v-bind=\u0026#34;$attrs\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ` }) \u0026lt;!--这样一来，所有写在 date-picker 上的 attribute 将会绑定在 input 元素上--\u0026gt;          style    对象语法\n  1 2 3 4 5 6 7  \u0026lt;div :style=\u0026#34;{color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;14px\u0026#39;, borderRadius: borderRadius}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; data(){ return { borderRadius: \u0026#39;4px\u0026#39; } }       也可以直接绑定到一个样式对象\n  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div :style=\u0026#34;styleObject\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; data(){ return { styleObject: { color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;14px\u0026#39;, borderRadius: \u0026#39;4px\u0026#39; }\t} }       数组语法\n  可以使用数组语法包含多个样式对象\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div :style=\u0026#34;[borderStyle, textStyle]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; data(){ return { borderStyle: { border: \u0026#39;1px solid red\u0026#39;, borderRadius: \u0026#39;4px\u0026#39;, }, textStyle: { fontSize: \u0026#39;14px\u0026#39;, color: \u0026#39;gray\u0026#39; } } }          v-for    v-if的优先级高于v-for，当两个指令同时作用于一个元素身上时，你需要你知道你在干什么\n   当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。\n   用比较简单的描述是，如果 v-for渲染出来的列表没有绑定key，那么在v-for绑定值变化的时候，Vue 是基于绑定值的索引来更新 DOM 树的\n  查看这个例子\n 我们将三个 input 元素的值改为 test1、test2、test3 然后删除第二个元素，按照直觉来说，剩下的应该只有 test1 和 test3，但结果是 test1 和 test2，why? 很简单，我们改变了v-for绑定值的 index，之前是0,1,2，删除后是0, 1，相当于删除了索引为 2 的元素，那么在这个 list 对应的 DOM 树中，也会去删除索引为 2 的节点，所以反应到页面上是 test1 和 test2 这就是文档中所说的依赖子组件状态或临时DOM状态，在这种情况下我们需要绑定key值来明确地告诉 Vue 我们想要删除的节点到底是哪一个，而不是让索引做主    为了让 Vue 可以监听到数组的变化，Vue 改写了以下数组方法：\n push pop shift unshift splice sort reverse    代替变更方法更好的办法是直接替换数组\n     事件处理    在内联语句中使用@eventName这样的方法来处理事件\n  1  \u0026lt;div @click=\u0026#34;f\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;     1 2 3 4 5 6 7  methods: { // e这个参数我们在绑定事件回调函数的时候并没有传啊？that\u0026#39;s ok，vue 会帮我们传的  // 这样的写法，vue 会在调用回调函数时默认帮我们传一个 event 对象 \tf(e){ console.log(e) } }     1  \u0026lt;div @click=\u0026#34;f(\u0026#39;message\u0026#39;, $event)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;     1 2 3 4 5 6 7 8  methods: { f(message,e){ // 当我们需要其他参数时，并且还想接收到 event 对象  // 我们需要在内联语句中显示的传递这个参数，使用 $event 这个变量，你问这个哪来的？去问 Evan You  console.log(`message is ${message}`) console.log(e) } }       一个事件可以绑定多个回调函数，使用逗号分割\n  1  \u0026lt;div @click=\u0026#34;doOne($event), doTwo($event)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;       事件修饰符\n  .stop阻止事件冒泡\n  .prevent阻止事件默认行为\n  .capture使用事件捕获模式\n  .self触发事件的元素只能是本身\n  .once事件只会触发一次\n  .passive文档解释我没太看懂，看了下 MDN，将 MDN 的解释照搬过来\n   passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看 使用 passive 改善的滚屏性能 了解更多.\n        v-model   .lazy会将触发事件由input改变为change .number将输入值转变为Number类型 .trim过滤输入值的首尾空白字符       Component     在自定义组件上使用 v-model  v-model本质上是一个语法糖，当我们剥开包装纸，其实是这样的\n1 2 3 4 5 6 7 8  \u0026lt;custom-input v-model=\u0026#34;searchText\u0026#34; \u0026gt;\u0026lt;/custom-input\u0026gt; \u0026lt;custom-input :model-value=\u0026#34;searchText\u0026#34; @update:model-value=\u0026#34;searchText = $event\u0026#34; \u0026gt;\u0026lt;/custom-input\u0026gt;    为了让它正常工作，这个组件内的 \u0026lt;input\u0026gt; 必须：\n 将其 value attribute 绑定到一个名叫 modelValue 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出   当然，我们也可以自定这个值，并不一定是 modelValue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;value\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:xxx\u0026#39;, $event.target.value)\u0026#34; \u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // props 接收一个名为 xxx 的 property defineProps({ xxx: { type: String, required: true } }) \u0026lt;/script\u0026gt;   当然，我们也可以在内部的input上使用v-model，不过需要改变一下写法，这里直接照搬文档\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  app.component(\u0026#39;custom-input\u0026#39;, { props: [\u0026#39;xxx\u0026#39;], emits: [\u0026#39;update:xxx\u0026#39;], template: ` \u0026lt;input v-model=\u0026#34;value\u0026#34;\u0026gt; `, computed: { value: { get() { return this.modelValue }, set(value) { this.$emit(\u0026#39;update:modelValue\u0026#39;, value) } } } })      使用 emits 定义组件发出的事件  1 2 3  app.component(\u0026#39;custom-form\u0026#39;, { emits: [\u0026#39;inFocus\u0026#39;, \u0026#39;submit\u0026#39;] })   当在 emits 选项中定义了原生事件 (如 click) 时，将使用组件中的事件替代原生事件侦听器。\n  这句话的意思是，如果我们在一个自定义组件内使用emits定义了组件发出的事件，那么在该组件上定义相同的事件（也就是原生事件侦听器）将不会触发，而是改用组件内定义的事件触发\n  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;script setup\u0026gt; import MyButton from \u0026#39;./components/MyButton.vue\u0026#39; import {ref} from \u0026#34;vue\u0026#34;; const f = () =\u0026gt; { console.log(\u0026#39;customize element tigger\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;MyButton label=\u0026#34;click me\u0026#34; @click=\u0026#34;f\u0026#34;\u0026gt;\u0026lt;/MyButton\u0026gt; \u0026lt;/template\u0026gt;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;!-- MyButton.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;f\u0026#34;\u0026gt; {{ label }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; defineProps({ label: { type: String, default: \u0026#39;\u0026#39;, required: false } }) const f = () =\u0026gt; { console.log(\u0026#39;component click tigger\u0026#39;); } // 如果没有使用emits，那么我们点击这个按钮将会触发两次click defineEmits([\u0026#39;click\u0026#39;]) \u0026lt;/script\u0026gt;     在 2.x 中，如果 MyButton 组件上定义了监听了 click 事件，但是组件内部没有对其处理的话，是触发不了这个事件的，必须使用.native才能触发\n  1 2 3 4 5  \u0026lt;!-- MyButton.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button\u0026gt;click me\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt;     1  \u0026lt;my-button @click=f\u0026gt;\u0026lt;/my-button\u0026gt;     1 2 3 4 5 6 7  methods:{ // 这个f是不会被触发的，除非是组件内部对click做出反应抛出一个click事件，或者在组件上使用 .native 修饰符  // .native 会将组件上的事件监听绑定到组件内部的根元素上 \tf(){ console.log(\u0026#39;tigger\u0026#39;) } }       emits还可以验证抛出事件\n 要添加验证，请为事件分配一个函数，该函数接收传递给 $emit 调用的参数，并返回一个布尔值以指示事件是否有效。\n   1 2 3 4 5 6 7 8 9 10 11 12 13  emits: { // 没有验证  click: null, // 验证 submit 事件  submit: ({ email, password }) =\u0026gt; { if (email \u0026amp;\u0026amp; password) { return true } else { console.warn(\u0026#39;Invalid submit event payload!\u0026#39;) return false } } }        插槽  备用内容/默认内容：\n 可以给插槽指定默认内容，当父组件在使用该组件时且并未提供任何插槽内容，默认内容将会被渲染  具名插槽：\n 给slot标签添加一个name的 Attribute，然后在父组件中使用\u0026lt;template v-slot:slotName\u0026gt;指定使用哪一个插槽，slot没有name的会当作default 插槽的名称也可以使用动态指令参数 具名插槽还可以使用缩写，但只能在有其他参数时使用（有多个插槽且需要提供名称时），将v-sot替换为#，使用缩写是需要使用明确的插槽名  作用域插槽\n 让父组件能够访问子组件通过插槽暴露的数据 子组件：\u0026lt;slot :dataName=data\u0026gt;\u0026lt;/slot\u0026gt;，父组件通过v-slot:default=\u0026quot;slotProps\u0026quot;来访问，slotProps是一个对象，里面包含了子组件插槽所暴露的数据项，default表示这是默认插槽，参考上面的具名插槽 当然，我们还可以使用ES6的解构语法：v-slot:default={dataName}     Provide / Inject  相当于“长距离 props”，子组件并不需要知道 inject 的 property 来自哪里，父组件也不需要知道哪些子组件使用了它 provide 的 property。\nprovide 要访问组件实例的 property 需要将 provide 写为一个返回对象的函数\nprovide 传递的内容并不是响应式的，我们可以使用 computed 来做到响应式\n   Composition API  这个算是Vue3 的最大更新了，这个 composition api 让我感觉 Vue3 现在确实是一个 framework，而不是一个 library，composition api 允许我们分离逻辑代码，使得单文件组件中的逻辑更加清晰有条理，在以往的 options api 中，如果我们有一个较重的组件，里面的data可能包含十多个 property，methods中的方法可能每一个都包含N行代码，阅读十分困难，而且逻辑关联不清楚。\n   Setup  setup函数接收两个参数：\n props context     Props  与 options api 的 props 一样，它是响应式的。\n1 2 3 4 5 6 7 8  export default { props: { title: String }, setup(props) { console.log(props.title) } }    但是，因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。\n 如果要解构 prop，需要使用toRefs函数来完成\n1 2 3 4 5 6 7  import { toRefs } from \u0026#39;vue\u0026#39; setup(props) { const { title } = toRefs(props) console.log(title.value) }   如果title是可选的prop（required: false），那么传入的props中可能没有这个titile，这种情况toRefs不会创建一个ref，需要使用toRef替代它\n1 2 3 4 5  import { toRef } from \u0026#39;vue\u0026#39; setup(props) { const title = toRef(props, \u0026#39;title\u0026#39;) console.log(title.value) }      Context  传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  export default { setup(props, context) { // Attribute (非响应式对象，等同于 $attrs)  console.log(context.attrs) // 插槽 (非响应式对象，等同于 $slots)  console.log(context.slots) // 触发事件 (方法，等同于 $emit)  console.log(context.emit) // 暴露公共 property (函数)  console.log(context.expose) } }   context是一个普通的 JavaScript 对象， 可以使用解构\n   Provide / Inject  在 composition api 中，provide 需要从 vue 中 import，其次 provide 变为一个函数，接收连个参数：key，value\ninject 相同，接收两个参数：需要 inject 的 property 的 key，默认值（可选）\n为了使 provide 和 inject 的值具有响应性，需要在 provide 时使用ref或reactive\n对于响应式的 property，尽量在 provide 处进行修改，跟 props 的单向数据流相似。如果需要在 inject 处更新 property，可以通过 provide 暴露一个更新方法。\n   模板引用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;root\u0026#34;\u0026gt;This is a root element\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39; export default { setup() { const root = ref(null) onMounted(() =\u0026gt; { // DOM 元素将在初始渲染后分配给 ref  console.log(root.value) // \u0026lt;div\u0026gt;This is a root element\u0026lt;/div\u0026gt;  }) return { root } } } \u0026lt;/script\u0026gt;   watch()和watchEffect()在 DOM 挂载或更新之前运行，所以在这里面运行时，模板引用还未更新，可以使用选项{flush: 'post'}，这将在 DOM 更新后运行，确保模板引用和 DOM 保持同步。\n   Mixin  mixin 对象的所有选项将被“混合”入组件本身\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const myMixin = { created() { this.hello() }, methods: { hello() { console.log(\u0026#39;hello from mixin!\u0026#39;) } } } // 定义一个使用此 mixin 对象的应用 const app = Vue.createApp({ mixins: [myMixin] }) app.mount(\u0026#39;#mixins-basic\u0026#39;) // =\u0026gt; \u0026#34;hello from mixin!\u0026#34;    当组件和 mixin 对象拥有同名选项时，这些选项将会合并  data 返回对象中的 property 重名，将会以组件自身数据优先合并 钩子函数将会合并为一个数组，并依次调用，mixin的钩子先于组件钩子调用 其他值为对象的选项重名时，将会合并，对象中的 property 重名时，以组件自身的 property 优先    mixin 也可以全局注册，但会影响每一个创建的组件，谨慎使用\n   Teleport  允许我们控制在 DOM 中哪个父节点下渲染 HTML，一个例子时 toast 组件的 content 部分，我们希望他是基于body定位的，在vue2 中我是通过模板引用拿到元素，然后将其append到body中，现在 teleport 可以直接让我们将 content 部分传送到body标签下：\u0026lt;teleport to=\u0026quot;body\u0026quot;\u0026gt;组件内容\u0026lt;/teleport\u0026gt;\n","date":"Jan 18","permalink":"https://zinkwu.blog/articles/vue3-docs-basic-notes/","tags":["Vue3"],"title":"Vue3 文档笔记-基础篇"},{"categories":null,"contents":"之前康复训练，写了一个组件库，涵盖了：\n 单元测试 自动化集成 上传至npm 书写文档  接下来总结下每一步\n   单元测试  单元测试使用了Chai、Karma、Mocha、Siono\n Chai.js 是一个断言库 Karma 是一个测试运行容器，可以呼起浏览器运行测试代码 Mocha 是一个测试框架，参考了阮一峰的文章 Siono 作为 mock 工具提供间谍函数等，可以让我们在测试中测试组件的事件支持  其中难点在于如何将这个几个工具搭配起来构成一套完整的测试环境，除了google就是看文档\u0026hellip;\n   自动化集成  当然，我也不想每次写完代码都自己手动跑一遍测试代码，所以我选择了GitHub Actions，在每次push代码时自动测试，失败了会有邮件通知\n   上传至NPM  写了库，总是想 share 出去的\n1 2 3 4 5 6  # 登录 npm adduser # 根据提示填写 # 发布 npm publish      书写文档  文档方面，选择了 VuePress，就图个文档易读\n","date":"Jan 13","permalink":"https://zinkwu.blog/articles/publish-yourself-npm-package/","tags":null,"title":"康复训练之 Vue2 UI 库开发总结"},{"categories":null,"contents":"   install wsl2  参照官方文档\n   install oh-my-zsh  先安装 zsh\n1 2 3 4 5 6 7 8  sudo apt install zsh zsh --version which zsh # $ZSH_PATH 是 which zsh 的值 chsh -s $ZSH_PATH   安装 oh-my-zsh\n1 2 3 4 5  sh -c \u0026#34;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # or sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34;   此时你的根目录下应该有一个 .oh-my-zsh 目录 plugins 目录是存放插件的地方，themes 是存放主题的地方\n现在让我们来试着修改主题\n1  vim ~/.zshrc   找到 ZSH_THEME= 这一行，修改为 ys，然后在 bash 中运行 source ~/.zshrc\n你也可以先花一些时间在这里找到你喜欢的主题\n接下来我们搞一些常用插件\n1 2 3 4 5 6  vim ~/.zshrc # 找到 plugins=(...) 这一行 # 我目前只使用了这些插件 plugins=(cp themes git git-open z zsh-autosuggestions zsh-syntax-highlighting)   你可以在这里找到 oh-my-zsh 自带插件的用法\n下面示范一下如何安装第三方插件，以 zsh-autosuggestions 和 zsh-syntax-highlighting 举例\n1 2 3 4 5 6 7 8 9 10  cd ~/.oh-my-zsh/plugins git clone https://github.com/zsh-users/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git # zsh-syntax-highlighting 这个插件需要处于 plugins=(...) 的末尾 vim ~/.zshrc # 在.zshrc 中添加下面一行 source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh      install node  我们使用 nvs 来管理 node 的版本\n安装按照官方文档一把梭就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export NVS_HOME=\u0026#34;$HOME/.nvs\u0026#34; git clone https://github.com/jasongin/nvs \u0026#34;$NVS_HOME\u0026#34; . \u0026#34;$NVS_HOME/nvs.sh\u0026#34; install # 安装最新的 LTS 版本 nvs add lts # 配置为默认版本 nvs link lts # 安装其他版本尝尝鲜 nvs add 12 # 查看已安装的版本 nvs ls # 在当前 Shell 切换版本 nvs use 12   Node 版本大于等于 16.9.0 之后默认安装 corepack，相当于包管理器的管理器\n1 2 3 4 5 6 7  corepack enable yarn -v which yarn pnpm -v which pnpm   使用 nvs 时，默认的 prefix 是当前激活的 Node.js 版本的安装路径。\n带来一个问题是：切换版本之后，之前安装全局命令模块需要重新安装，非常不方便。\n解决方案是配置统一的全局模块安装路径到 ~/.npm-global，如下：\n1 2  mkdir -p ~/.npm-global npm config set prefix ~/.npm-global   还需要配置环境变量到 ~/.zshrc 中\n1 2  echo \u0026#34;export PATH=~/.npm-global/bin:$PATH\u0026#34; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc   ok，这样我们已经得到一个基本可用的开发环境了\n 2021-1-8 更新\n   代理设置  windows: clash\ngoogle clash for windows 即可\nwsl2: proxychains\n1 2 3 4 5 6 7  sudo apt install proxychains mkdir ~/.proxychains sudo cp /etc/proxychains.conf ~/.proxychains/proxychains.conf vim ~/.zshrc   在.zshrc中添加以下代码\n1 2 3 4 5 6  windows_ip=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;) sed -i \u0026#39;/socks5/d\u0026#39; $HOME/.proxychains/proxychains.conf # \u0026#39;$windows_ip\u0026#39; 1080\u0026#39; 请将 1080 改为你自己的代理端口 sed -i \u0026#39;$a socks5 \u0026#39;$windows_ip\u0026#39; 1080\u0026#39; $HOME/.proxychains/proxychains.conf alias ss=\u0026#39;proxychains\u0026#39;   于是我们可以 ss git clone xxx\n如果 proxychains 连接 windows 代理超时，请关闭防火墙\n","date":"Dec 29","permalink":"https://zinkwu.blog/articles/wsl2-install-and-oh-my-zsh-config/","tags":null,"title":"wsl2 oh-my-zsh 配置"},{"categories":null,"contents":"为什么要从 Second Commit 开始阅读呢？\n 答案来自我看过我的一篇博客，但是关于 First Commit，基本是关于 Grunt 的配置，现代前端开发中，多以使用 Webpack 为主，所以粗略看了一下之后并无记录的打算。  不罗嗦，直接看代码\n在这段代码我们已经触及了 Vue 的核心：data bind，实际上也跟我们现在写的 Vue 差不多（当然，这里不是指 SFC ）\n首先在 HTML 部分，我们看到了文档中的“Mustache”语法，接下来我们看看最初的 data bind 是如何实现的。\n在第 23 行，var content = el.innerHTML.replace(/\\{\\{(.*)\\}\\}/g, markToken)，用正则表达式匹配{{...}}，\n关于 String.prototype.replace()\n 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。\n 当第二个参数是一个函数时，函数接收多个参数，第一个参数match，表示匹配的子串，比如：{{msg}}、{{what}}等，第二个参数用于匹配正则表达式中括号匹配到的字符串，就是匹配正则表达式的这一部分：(.*)，并且这里可以接收多个参数：p1,p2,p3...，他们分别是括号对应的索引，具体参见 MDN。\nok，我们继续回到 23 行，每次匹配执行后都会执行这个函数，这个函数首先会往bindings内填充key:value，key 是{{}}内的值，value 则是一个空对象，然后 return 一个字符串 return '\u0026lt;span ' + bindingMark + '=\u0026quot;' + variable +'\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;'\n接着遍历 bindings 执行 bind 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function bind (variable) { bindings[variable].els = el.querySelectorAll(\u0026#39;[\u0026#39; + bindingMark + \u0026#39;=\u0026#34;\u0026#39; + variable + \u0026#39;\u0026#34;]\u0026#39;) ;[].forEach.call(bindings[variable].els, function (e) { e.removeAttribute(bindingMark) }) Object.defineProperty(data, variable, { set: function (newVal) { [].forEach.call(bindings[variable].els, function (e) { bindings[variable].value = e.textContent = newVal }) }, get: function () { return bindings[variable].value } }) }   首先会找到含有bindingMark=... Attribute的 Element，并在bindings对应的key中记录它，接着再删除元素中的bindingMark Attribute，最后使用Object.defineProperty来做到 data bind，这也是 Vue 数据响应的核心。\n接着遍历initData，将initData中的值浅拷贝给data，上面已经使用Object.defineProperty定义了data对于{{}}中值的get和set。所以此时将initData中的键值对拷贝到data中，就会触发对应 property 的set，这里也就完成了对模板的数据更新。\n这里已经包含了 data bind 和数据响应的核心，当然，这只是一个简单的实现。此外，Vue 的另一个核心：component system 还没有出现，后面会慢慢看到。\n有兴趣的同学可以听一下尤小右当初为什么要开发 Vue 的 podcast，很有意思，在这里你能很快找到 Vue 的核心并且理解为什么需要它们。\n","date":"Dec 23","permalink":"https://zinkwu.blog/articles/vue-source-read-second-commit/","tags":["Vue"],"title":"Vue源码阅读记-Second Commit"},{"categories":null,"contents":"首先请确保已安装 Git\n   下载字体  下载并安装字体，为了修复乱码\n地址: https://github.com/ryanoasis/nerd-fonts/releases 我使用的是 Hack。\n   Install PowerShell  安装方式很多，自行搜索，我是直接从 Microsoft store 安装\n   Terminal 的基本设置  修改字体为你下载的字体 开启亚克力效果 设置默认终端    安装 Scoop  1  iwr -useb get.scoop.sh | iex      安装 Neovim  1 2  scoop install neovim gcc nvim --version      PowerShell 配置  1 2  # 确认处于 user\\xxx 目录下 nvim .config/powershell/user_profile.ps1   让我们先搞点 alias\n1 2 3 4  # Alias Set-Alias vim nvim Set-Alias ll ls Set-Alias g git   1 2 3  if(!(Test-Path $PROFILE.CurrentUserCurrentHost)) {New-Item -Type File -Path $PROFILE.CurrentUserCurrentHost -Force} nvim $PROFILE.CurrentUserCurrentHost   输入以下代码并:wq\n1  . $env:USERPROFILE\\.config\\powershell\\user_profile.ps1   完成以上操作我们就可以重启 Terminal\n1 2 3  # 验证我们的配置文件是否生效 ll g --version      安装 posh-git/oh-my-posh/Terminal-Icons  1 2 3 4 5  Install-Module posh-git -Scope CurrentUser -Force Install-Module oh-my-posh -Scope CurrentUser -Force Install-Module -Name Terminal-Icons -Repository PSGallery -Force # 确保当前在 user/xxx 下 vim ./.config/powershell/user_profile.ps1   导入模块\n1 2 3 4 5 6 7 8  # Prompt Import-Module posh-git Import-Module oh-my-posh Set-PoshPrompt -Theme JanDeDobbeleer # Icons Import-Module -Name Terminal-Icons # 设置主题，后续可以根据自己的喜好更改，google oh-my-posh theme 查看相关主题   此时你终端内的图标应该会改变    安装 z  z 是一个快速跳转目录的命令，如何使用请查看文档 https://github.com/rupa/z\n1  Install-Module -Name z -Force      安装 PSReadLine  1 2 3  Install-Module -Name PSReadLine -AllowPrerelease -Scope CurrentUser -Force -SkipPublisherCheck vim ./.config/powershell/user_profile.ps1   1 2 3 4 5 6  # PSReadLine Set-PSReadLineOption -EditMode Emacs Set-PSReadLineOption -BellStyle None Set-PSReadLineKeyHandler -Chord \u0026#39;Ctrl+d\u0026#39; -Function DeleteChar Set-PSReadLineOption -PredictionSource History Set-PSReadLineOption -PredictionViewStyle ListView   此时你输入命令得到的结果应该跟我差不多    安装 PSFzf  1 2 3  Install-Module -Name PSFzf -Scope CurrentUser -Force vim ./.config/powershell/user_profile.ps1   1 2 3  # Fzf Import-Module PSFzf Set-PsFzfOption -PSReadlineChordProvider \u0026#39;Ctrl+f\u0026#39; -PSReadlineChordReverseHistory \u0026#39;Ctrl+r\u0026#39;   用法基本跟 fzf 相似，可查看文档学习: https://github.com/kelleyma49/PSFzf\n   搞个 which 和 touch 命令出来  1 2  # 编辑 powershell 配置文件 vim ./.config/powershell/user_profile.ps1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Utilities function which ($command) { Get-Command -Name $command -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path -ErrorAction SilentlyContinue } function touch($name){ if ($name) { $file_path = Split-Path -Path $name $file_name = Split-Path -Path $name -Leaf if ($file_path -eq \u0026#34;\u0026#34;) { $file_path = \u0026#34;.\u0026#34; } if (-Not (Test-Path($file_path))) { New-Item -ItemType \u0026#34;directory\u0026#34; -Path $file_path } New-Item -Path $file_path -Name $file_name -ItemType \u0026#34;file\u0026#34; } else { Write-Host \u0026#34;Command to create new file.\u0026#34; } }   ","date":"Dec 23","permalink":"https://zinkwu.blog/articles/windows-terminal-build/","tags":null,"title":"Win11 PowerShell 配置"},{"categories":null,"contents":"你好，我是Zink，一名工程师，同时也是一名业余鼓手\u0026amp;板混\n好读书，读的书比较杂，理论、小说都涉猎一些，最喜欢的书是强风吹拂、横道世之介。阅读对于我来说是一个避难所，当外界的焦虑、压力袭来时，我喜欢躲进书中以期平静。\n关于滑板，一次偶然在YouTube刷到了 Luis Mora 的视频，从此喜欢上了滑板，我很享受站在滑板上破风前进的时候，很自在。\n","date":"Dec 21","permalink":"https://zinkwu.blog/about/","tags":null,"title":"About"},{"categories":null,"contents":"   什么是 Grid   Grid 是一种 CSS 布局方案 将浏览器划分为一个个网格并可以任意组合 Flex 和 Grid 看似相似，但内在相差很大  Flex 是轴线布局，只能指定 Item 处于轴线某个位置 Grid 是网格布局，将容器划分为行和列，产生单元格，并指定 Item 处于某个单元格中       基本概念   row 行 column 列 grid line 网格线 cell 单元格 将容器设置为display: grid后，容器内子元素的float、diaplay: inline-block、display: table-cell、vertical-align和column-*等设置都会失效  这个游戏能帮你更好的学习 grid\n   容器属性     grid-template-columns 和 grid-template-rows  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;9\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13  .container{ display: grid; grid-template-columns: 100px 100px 100px; /*将元素分为三列,，每一列的宽度是100px*/ grid-template-rows: 100px 100px 100px; /*将元素分为三行，每一行的高度是100px*/ /* 产生一个三行三列的网格，列宽和行高都是100px 除了使用px单位，也可以使用百分比 */ } .container \u0026gt; div { border: 1px solid blue; margin: 5px; }      repeat()  1 2 3 4 5 6 7  .container{ display: grid; width: 300px; height: 300px; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%); }   repeat()的第一个参数表示重复的次数，第二个参数表示重复的值，不过它并不是只能接受两个参数\n1 2 3 4  .container{ display: grid; grid-template-columns: repeat(3, 20px 50px 30px); }   以上代码定义了9列，1、4、7列的宽为20px；2、5、8列的宽为50px；3、6、9列的宽为30px\n   auto-fill  当单元格的大小是固定的，但容器大小不确定，此时我们希望每一行、每一列尽量容纳多的单元格，这是可以使用auto-fill表示自动填充\n1 2 3 4  .container { display: grid; grid-template-columns: repeat(auto-fill, 100px); }      fr  fr能表示子元素大小的比例关系\n1 2 3 4  .container { display: grid; grid-template-columns: 1fr 2fr 1fr; }   以上代码表示第二列的宽是第一列和第三列的两倍，使用fr时也可以结合绝对单位：grid-template-columns: 150px 2fr 1fr;\n   minmax()  1 2 3 4  .container{ display: grid; grid-template-columns: 1fr 1fr minmax(100px, 2fr); }   以上代码表示第三列的宽最小值为100px，最大值为第一列和第二列的两倍\n   auto  auto表示浏览器自己决定长度\n1 2 3 4  .container{ display: grid; grid-template-columns: 100px auto 100px; }      指定网格线名称  1 2 3 4 5  .container{ display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] 100px [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] 100px [r4]; }   网格布局允许同一根线有多个名字，比如[start-line r1]\n   grid-row-gap、grid-column-gap、grid-gap  grid-row-gap设置行与行之间的间隔，grid-column-gap设置列与列之间的间隔，gird-gap则是两个属性的缩写\n1 2 3 4 5 6 7 8 9 10 11 12  .container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-column-gap: 5px; grid-row-gap: 5px; /* grid-gap: 5px 5px; grid-gap: row-gap column-gap; 如果忽略第二个值，那么浏览器会默认第二个值与第一个值相等 */ }      grid-auto-flow  grid的放置顺序为先行后列，先填满第一行，再开始填充第二行，grid-auto-flow可以改变这个顺序。\n1 2 3 4 5 6  .container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-flow: column; /* 先列后行，默认值是 row */ }   grid-auto-flow还有另外两个值：row-dense、cloumn-dense，表示让子元素尽可能密集排布，哪怕转换元素的顺序。\n   justify-items、align-items、place-items  justify-items用于设置单元格内容的水平位置（左中右），align-items用于设置单元格内容的垂直位置（左中右）\n1 2 3 4  .container { justify-items: start | end | center | stretch; align-items: start | end | center | stretch; }   place-items以上两个属性的缩写\n1 2 3 4  .contianer{ place-items: \u0026lt;align-items\u0026gt; \u0026lt;justify-items\u0026gt;; } /*如果忽略第一个值，浏览器默认第二个值等于第一个值*/      justify-content、align-content、place-content  作用跟上面三个属性相似，不过*-content表示的是容器内整个内容区域的位置，*-items表示子元素在单元格中的位置\n1 2 3 4 5  .container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; } /* space-evenly 表示子元素之间的间距相等，子元素与容器边框之间的间距也相等 */      子元素属性     grid-column-start、grid-column-end、grid-row-start、grid-start-end、grid-column、grid-start  以上属性可以指定子元素在容器内占据的单元格位置\n1 2 3 4 5 6 7 8 9 10  .container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; } .item{ grid-column-start: 1; grid-column-end: 3 }   以上代码指定了item占据了2个单元格，以第一根垂直网格线为起点，以第三根垂直网格线为终点，不仅可以写第几根网格线，也还可以写网格线名称。\n也可以使用span来表示跨越多少个网格\n1 2 3 4 5  .item{ grid-column-start: 1; grid-column-end: span 3; } /*从第一根垂直网格线开始，跨越三个单元格*/   grid-column、grid-row则是对应属性的缩写\n1 2 3 4 5  .item { grid-column: \u0026lt;start-line\u0026gt; / \u0026lt;end-line\u0026gt;; grid-row: \u0026lt;start-line\u0026gt; / \u0026lt;end-line\u0026gt;; } /* 同样可以使用 span */      justify-self、align-self、place-self  跟justify-items、align-items、space-items用法相同，不过*-self仅作用与单个子元素\n1 2 3 4  .item { justify-self: start | end | center | stretch; align-self: start | end | center | stretch; }   place-items是两个属性的缩写\n1 2 3  .item{ place-self: \u0026lt;align-self\u0026gt; \u0026lt;justify-self\u0026gt;; }      区域相关的内容     grid-template-areas  网格布局可以指定区域，一个区域又单个或多个单元格组成，grid-template-areas用于自定义区域\n1 2 3 4 5 6 7 8  .container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: repeat(3 100px); grid-template-areas: \u0026#39;a b c\u0026#39; \u0026#39;d e f\u0026#39; \u0026#39;g h i\u0026#39; }   也可以将多个单元格合并为一个区域\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: repeat(3 100px); grid-template-areas: \u0026#39;a a a\u0026#39; \u0026#39;b b b\u0026#39; \u0026#39;c c c\u0026#39;; } /* 如果某个区域不需要利用，则可以用\u0026#34;.\u0026#34;来表示 注意，区域的命名会影响到网格线。 每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 */      grid-area  用于指定子元素放在哪一个区域\n1 2 3  .item { grid-area: e; }   grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。\n1 2 3  .item { grid-area: \u0026lt;row-start\u0026gt; / \u0026lt;column-start\u0026gt; / \u0026lt;row-end\u0026gt; / \u0026lt;column-end\u0026gt;; }   ","date":"Dec 13","permalink":"https://zinkwu.blog/articles/grid-layout/","tags":["CSS"],"title":"Grid Layout"},{"categories":null,"contents":"  修改软件源为 aliyun\n  更新系统\n  1 2 3 4 5  # 更新本地包数据库 sudo apt update # 更新所有已安装的包 sudo apt upgrade       安装 git\n  1  apt install git       安装 Terminnator\n  1 2 3  sudo add-apt-repository ppa:gnome-terminator sudo apt update sudo apt install terminator       安装 zsh\n  1 2  apt install zsh chsh -s `which zsh`       安装 oh-my-zsh\n  1  wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh       安装 zsh 插件\n  autojump\n  1 2 3 4  apt install autojump echo \u0026#34;[[ -s /usr/share/autojump/autojump.sh ]] \u0026amp;\u0026amp; . /usr/share/autojump/autojump.sh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc       zsh-autosuggestions\n  1 2 3 4 5  git clone https://github.com/zsh-users/zsh-autosuggestions cp -r zsh-autosuggestions/ ~/.oh-my-zsh/custom/plugins echo \u0026#34;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc       zsh-syntax-highlighting\n  1 2 3 4 5  git clone https://github.com/zsh-users/zsh-syntax-highlighting.git cp -r zsh-syntax-highlighting/ ~/.oh-my-zsh/custom/plugins echo \u0026#34;source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc       1  echo \u0026#34;plugins=(autojump zsh-autosuggestion zsh-syntax-highlighting)\u0026#34; \u0026gt;\u0026gt; ~/.zshrc       安装 clash\n  https://github.com/Dreamacro/clash/releases/tag/v1.8.0\n 找到你所需要的版本    下载后提取到你指定的目录并 rename 为 clash\n  1 2 3 4 5 6  # 需在上一步的目录下进行 wget -O config.yaml 订阅地址?clash=1\u0026amp;log-level=info # 这里的订阅地址需要转换一下，不然生成出的config不正确，google搜索订阅转换即可 chmod +x clash ./clash -d .     浏览器打开 http://clash.razord.top/#/proxies ，显示无误即表示ok\n  系统设定网络代理为手动 127.0.0.1:port\n    安装 chrome\n  1 2 3  wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo apt install ./google-chrome-stable_current_amd64.deb       ","date":"Nov 24","permalink":"https://zinkwu.blog/articles/ubuntu-config/","tags":null,"title":"Ubuntu 20.04.3 LTS 配置"},{"categories":null,"contents":"将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\nex1:\n输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] tip:\n两个链表的节点数目范围是 [0, 50] -100 \u0026lt;= Node.val \u0026lt;= 100 l1 和 l2 均按 非递减顺序 排列 code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { if(!l1 \u0026amp;\u0026amp; !l2){ return null } if(!l1){ return l2 }else if(!l2){ return l1 } if(l1.val \u0026lt;= l2.val){ l1.next = mergeTwoLists(l1.next, l2) return l1 }else{ l2.next = mergeTwoLists(l1, l2.next) return l2 } };   ","date":"Jul 17","permalink":"https://zinkwu.blog/articles/metge-two-sorted-linked-list/","tags":["算法"],"title":"合并两个有序链表"},{"categories":null,"contents":"   否运算 not    ~\n  按位取反\n  0000 0011 ---[3] 1111 1100 1111 1101 ---[-3]    按位与 and    \u0026amp;\n  两个位都是1时，结果才为1，否则为0\n  5 \u0026amp; 3 0101 0011 ---- 0001 ---[1]    按位或 or    |\n  两个位都是0时，结果才为0，否则都为1\n  5 | 3 0101 0011 ---- 0111 ---[7]    异或（不带进位的加法）xor    ^\n  两个位相同为0，不同则为1\n  5 ^ 3 0101 0011 ---- 0110 ---[6]    左移    \u0026lt;\u0026lt;\n  向左进行移位操作，高位丢弃，低位补0\n  在计算机中相当于 乘以2的n次方，因为在计算机中以二进制存储数据\n  10 \u0026lt;\u0026lt; 2 === 40 0000 1010 \u0026lt;\u0026lt; 2 0010 1000 ---[40(10*2^2)]    右移   \u0026gt;\u0026gt; 向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位  [8] 0000 1000 \u0026gt;\u0026gt; 3 [1] 0000 0001 [-8] 1111 1000 \u0026gt;\u0026gt; 3 [-1] 1111 1111    字符串加法  字符串连接加法，会调用对象的toString方法，原生类型相应的表示，在连接一个很长的字符串加法时，JDK内部会自动转换为StringBuilder的调用，减轻内存压力，提高性能\n","date":"Oct 07","permalink":"https://zinkwu.blog/articles/bit-operation/","tags":null,"title":"位运算"},{"categories":null,"contents":"给你两个二进制字符串，返回它们的和（用二进制表示）。\n输入为 非空 字符串且只包含数字 1 和 0。\n示例1：\n 输入: a = \u0026ldquo;11\u0026rdquo;, b = \u0026ldquo;1\u0026rdquo; 输出: \u0026ldquo;100\u0026rdquo;\n 示例2：\n 输入: a = \u0026ldquo;1010\u0026rdquo;, b = \u0026ldquo;1011\u0026rdquo; 输出: \u0026ldquo;10101\u0026rdquo;\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //满二进一 var addBinary = function(a, b) { let sum = 0\t//保留上一次位数相加后是否进一  let result = \u0026#34;\u0026#34; for(let i = a.length -1, j = b.length-1; i \u0026gt;= 0 || j \u0026gt;= 0; i--, j--){ let count = sum\t//取sum的值，与本次遍历的两数相加  count += a[i] \u0026gt; 0 ? parseInt(a[i]) : 0 count += b[j] \u0026gt; 0 ? parseInt(b[j]) : 0 //count的值只可能为 0、1、2、3  result += count % 2 sum = Math.floor(count / 2)\t// count \u0026gt;= 2 时会进一  } result += sum == 1 ? sum : \u0026#34;\u0026#34; //最后要检查sum是否为1，为1则表示还需要进位  return result.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;) //反转，因为是从字符串末端开始遍历 };   ","date":"Jul 23","permalink":"https://zinkwu.blog/articles/add-binary/","tags":["算法"],"title":"二进制求和"},{"categories":null,"contents":"  树\n 树是一种常用的数据结构，用来模拟具有树状结构性质的数据集合 树的每一个节点有一个根植和一个包含所有子节点的列表。    二叉树\n 二叉树是一种更为典型的树状结构。二叉树每个节点最多具有两个子树，通常子树称为“左子树”和“右子树”    二叉树前序遍历\n 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树（根节点 -\u0026gt; 左子树 -\u0026gt; 右子树） 算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ // 递归 const preorderTraversal = function(root) { let result = [] function fn(root){ if(root !== null){ result.push(root.val) if(root.left) fn(root.left) if(root.right) fn(root.right) } } fn(root) return result };    二叉树中序遍历  先遍历左子树，然后访问根节点，最后遍历右子树（左子树 -\u0026gt; 根节点 -\u0026gt; 右子树） 算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ const inorderTraversal = function(root) { let result = [] function fn(root){ if(root !== null){ if(root.left) fn(root.left) result.push(root.val) if(root.right) fn(root.right) } } fn(root) return result };    二叉树后序遍历  先遍历左子树，然后遍历右子树，最后访问根节点（左子树 -\u0026gt; 右子树 -\u0026gt; 根节点） 算法    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ const postorderTraversal = function(root) { let result = [] function fn(root){ if(root !== null){ if(root.left) fn(root.left) if(root.right) fn(root.right) result.push(root.val) } } fn(root) return result };    二叉树层序遍历  算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ // 广度优先 前序 const levelOrder = function(root) { let levels = [] if(root === null) return levels function fn(node, level){ let len = levels.length if(len === level) levels.push([]) levels[level].push(node.val) if(node.left) fn(node.left, level+1) if(node.right) fn(node.right, level+1) } fn(root, 0) return levels };    二叉树最大深度  给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数 算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { // 写递归的一个重要思路就是相信这个函数能完成任务，此题带有动态规划的感觉  // 最大深度 = 1+Math.max(根节点的左子树最大深度, 根节点的右子树最大深度)  // 根节点的左子树最大深度 = 1 + Math.max(左子树的左子树最大深度, 左子树的右子树最大深度)  // 根节点的右子树最大深度 = 1 + Math.max(右子树的左子树最大深度, 右子树的右子树最大深度)  if(!root){ return 0 }else{ return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 } };    对称二叉树  给定一个二叉树，检查它是否是镜像对称的。 算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function(root) { return isMirroTree(root, root) }; function isMirroTree(root_1, root_2){ if(root_1 === null \u0026amp;\u0026amp; root_2 === null) return true if(root_1 === null || root_2 === null) return false return (root_1.val === root_2.val) \u0026amp;\u0026amp; isMirroTree(root_1.left, root_2.right) \u0026amp;\u0026amp; isMirroTree(root_1.right, root_2.left) }    路径总和  给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 算法：    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {boolean} */ var hasPathSum = function(root, sum) { return helper(root, sum) }; function helper(node, sum){ if(!node){ return false }else{ sum -= node.val } if(!node.left \u0026amp;\u0026amp; !node.right){ return sum === 0 } return helper(node.left, sum) || helper(node.right, sum) }   ","date":"Apr 24","permalink":"https://zinkwu.blog/articles/binary-tree/","tags":["数据结构"],"title":"二叉树基础"},{"categories":null,"contents":"输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例：\n输入：head = [1,3,2] 输出：[2,3,1] 限制：0 \u0026lt;= 链表长度 \u0026lt;= 10000\n解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  方法一：遍历链表，使用unshift将元素添加到数组头部 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { if(head === null) return [] let result = [] while(head){ result.unshift(head.val) head = head.next } return result }; 方法二：反转链表，遍历链表将元素push到数组 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { if(head === null) return [] head = reverseList(head) let result = [] while(head){ result.push(head.val) head = head.next } return result }; function reverseList(head){ let next; let pre; while(head){ next = head.next; head.next = pre; pre = head; head = next; } return pre }   ","date":"Mar 29","permalink":"https://zinkwu.blog/articles/print-linked-list/","tags":["算法"],"title":"从尾到头打印链表"},{"categories":null,"contents":"请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n输入：s = \u0026quot;We are happy.\u0026quot; 输出：\u0026quot;We%20are%20happy.\u0026quot;\n限制：0 \u0026lt;= s 的长度 \u0026lt;= 10000\n解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 方法一：正则 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { return s.replace(/ /g, \u0026#34;%20\u0026#34;) }; //方法二：遍历字符串 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { if (!s || !s.length) { return \u0026#34;\u0026#34;; } let result = \u0026#34;\u0026#34; for(let i = 0; i\u0026lt;s.length; i++){ if(s[i] === \u0026#34; \u0026#34;){ result += \u0026#34;%20\u0026#34; }else{ result += s[i] } } return result };   ","date":"Mar 28","permalink":"https://zinkwu.blog/articles/replace-spaces/","tags":["算法"],"title":"替换空格"},{"categories":null,"contents":"在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例： 现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000\n0 \u0026lt;= m \u0026lt;= 1000\n 解： 由于每行每列的元素大小都是递增的，所以在遍历时可以判断当前元素是否大于 tatget，如果大于，则开始下一轮遍历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function(matrix, target) { let result = false for(let i = 0; i \u0026lt; matrix.length; i++){ for(let j = 0; j \u0026lt; matrix[i].length; j++){ if(matrix[i][j] \u0026gt; target){ break } if(matrix[i][j] === target){ result = true return result } } } return result };   ","date":"Mar 26","permalink":"https://zinkwu.blog/articles/locating-a-2d-matrix/","tags":["算法"],"title":"二维数组中的查找"},{"categories":null,"contents":"找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 \u0026lt;= n \u0026lt;= 100000\n解： 哈希，构造一个空对象，遍历数组，每次遍历数组时检查 hash 中是否包含有该元素\n1 2 3 4 5 6 7 8  var findRepeatNumber = function(nums) { let hash = {} let result = [] for(let item of nums){ hash[item] ? result.push(item) : hash[item] = true } return result[0] };   ","date":"Mar 24","permalink":"https://zinkwu.blog/articles/array-repetition-numbers/","tags":["算法"],"title":"数组中重复的数字"},{"categories":null,"contents":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  解:\n 方法1:  暴力法：检查当前元素之后是否有符合条件的元素，时间复杂度为O(n^2)，空间复杂度O(1)    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for(let i = 0; i \u0026lt; nums.length; i++){ let num = target - nums[i] for(let j = i + 1; j \u0026lt; nums.length; j++){ if(nums[j] === num){ return [i, j] } } } return [] };    方法2：  Hash表：每次迭代都回头检查 Hash 中是否有匹配元素，没有的话则将元素插入 Hash 中，时间复杂度O(n)，空间复杂度O(n)    1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let hash = {} for(let i = 0; i \u0026lt; nums.length; i++){ let result = target - nums[i] if(hash[result] !== undefined) return [hash[result], i] hash[nums[i]] = i } return [] };   ","date":"Jan 14","permalink":"https://zinkwu.blog/articles/two-sum/","tags":["算法"],"title":"两数之和"},{"categories":null,"contents":"   链表的区别  链表也分为单链表和双链表。\n 单链表：每个节点包含 value 和 next，next 指向下一个节点 双链表：每个节点包含 prev、value 和 next，prev 指向前一个节点，next 指向下一个节点     单链表的实现  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  class Node{ constructor(value){ this.value = value this.next = null } } class MyLinkedList{ constructor(){ this.head = null this.length = 0 } // 按索引获取节点 value  get(index){ if(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; this.length){ let current = this.head if(index === 0){ return current.value }else{ let position = 0 while(position \u0026lt; index){ current = current.next position++ } return current.value } } return -1 } // 在头部添加节点  addAtHead(val){ const node = new Node(val) let current = this.head this.head = node this.head.next = current this.length++ } // 添加节点到尾部  addAtTail(val){ const node = new Node(val) if(this.length){ let current = this.head while(current.next){ current = current.next } current.next = node }else{ this.head = node } this.length++ } // 在给定位置添加节点  addAtIndex(index, val){ const node = new Node(val) let position = 0 let current = null let previous = null let length = this.length if(length === 0 \u0026amp;\u0026amp; index \u0026lt;= 0){ this.head = node this.length++ }else if (index \u0026lt;= 0){ this.addAtHead(val) }else if(index === length){ this.addAtTail(val) }else if(index \u0026gt; 0 \u0026amp;\u0026amp; index \u0026lt; length){ current = this.head while(position \u0026lt; index){ previous = current current = current.next position++ } previous.next = node node.next = current this.length++ } } // 按索引删除  deleteAtIndex(index){ if(index \u0026gt;= this.length) return let current = this.head let previous = null let position = 0 if(index === 0 \u0026amp;\u0026amp; index === this.length){ this.head = null }else if(index === 0 ){ this.head = current.next }else{ while(position \u0026lt; index){ previous = current current = current.next position++ } previous.next = current.next } this.length-- } }      双链表的实现  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  class Node{ constructor(value){ this.value = value this.next = null this.prev = null } } class MyLinkedList{ constructor(){ this.head = null this.length = 0 } get(index){ if(index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; this.length){ let current = this.head if(index === 0){ return current.value }else{ let position = 0 while(position \u0026lt; index){ current = current.next position++ } return current.value } } return -1 } addAtHead(val){ const node = new Node(val) let current = this.head this.head = node this.head.next = current this.length++ if(this.length === 1){ return }else{ current.prev = this.head } } addAtTail(val){ const node = new Node(val) if(this.length){ let current = this.head while(current.next){ current = current.next } current.next = node node.prev = current }else{ this.head = node } this.length++ } addAtIndex(index, val){ const node = new Node(val) let position = 0 let current = null let previous = null let length = this.length if(length === 0 \u0026amp;\u0026amp; index \u0026lt;= 0){ this.head = node this.length++ }else if (index \u0026lt;= 0){ this.addAtHead(val) }else if(index === length){ this.addAtTail(val) }else if(index \u0026gt; 0 \u0026amp;\u0026amp; index \u0026lt; length){ current = this.head while(position \u0026lt; index){ previous = current current = current.next position++ } previous.next = node current.prev = node node.prev = previous node.next = current this.length++ } } deleteAtIndex(index){ if(index \u0026gt;= this.length) return let current = this.head let previous = null let position = 0 if(index === 0 \u0026amp;\u0026amp; this.length === 1){ this.head = null }else if(index === 0){ this.head = current.next current.next.prev = null }else{ while(position \u0026lt; index){ previous = current current = current.next position++ } if(index === this.length - 1){ previous.next = null }else{ previous.next = current.next current.next.prev = previous } } this.length-- } }      环形链表   给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。\n 解法：双指针遍历 首先明确一个结论：head到入环点的距离 等于 相遇点到入环点的距离，推演过程有空补图=。=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var detectCycle = function(head) { if(!head || !head.next) return null let fastPoint = head let slowPoint = head while(fastPoint \u0026amp;\u0026amp; fastPoint.next){ fastPoint = fastPoint.next.next slowPoint = slowPoint.next if(fastPoint === slowPoint) { slowPoint = head while(fastPoint !== slowPoint){ fastPoint = fastPoint.next slowPoint = slowPoint.next } return slowPoint } } return null };   ","date":"Jan 06","permalink":"https://zinkwu.blog/articles/linked-list/","tags":["数据结构"],"title":"链表"},{"categories":null,"contents":"   栈  栈是一种线性数据结构，其修改顺序是后进先出(last in first out)，因此也被成为 LIFO表。 在现实生活中可以映射到我们堆叠在桌子上的书、餐具柜中队列的餐盘之类。\n我们可以用数组模拟栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Static{ constructor(){ this.items = [] } // 检查栈是否为空  get isEmpty(){ return !this.items.length } // 获取栈的长度  get size(){ return this.items.length } // 查看栈顶  get top(){ return this.items[this.items.length - 1] } // 入栈  push(val){ this.items.push(val) return this.items } // 出栈  pop(){ return this.items.pop() } // 清空栈  clear(){ this.items.length = [] return this.items } }       队列  与栈相反，队列是修改顺序是先进先出(first in first out)，称为 FIFO表。 在现实生活中可以映射到点餐队列、打印队列。\n用数组模拟队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Queue{ constructor(){ this.items = [] } // 检查队列是否为空  get isEmpty(){ return !this.items.length } // 获取队列的长度  get size(){ return this.items.length } // 获取首元素  get first(){ return this.items[0] } // 获取尾元素  get last(){ return this.items[this.items.length - 1] } // 入队  enqueue(val){ this.items.push(val) return this.items } // 出队  dequeue(){ return this.items.shift() } // 清空队列  clear(){ this.items.length = 0 } }   ","date":"Dec 18","permalink":"https://zinkwu.blog/articles/stack-queue/","tags":["数据结构"],"title":"栈、队列"},{"categories":null,"contents":"  判断输入的是 URL 还是搜索的关键字\n  转换非 ASCII 的 Unicode 字符\n 比如：中文、空格    检查HSTS 列表\n 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的 URL，如果这个 URL在列表里，则默认使用 HTTPS 协议而不是 HTTP 协议    查找域名的 IP 地址\n 查找浏览器的 DNS 缓存，没找到则执行下一步 查找操作系统中的 DNS 缓存，没找到则执行下一步 查找 OS 中的 hosts 文件，没找到则执行下一步 在 OS 的 LDNS 中查找域名对应的 IP（这一步可能会遇到 DNS 污染，解决方案为：1. 切换 DNS 服务器；2. 清空 DNS 缓存；3. 修改系统 hosts 文件，将域名与对应的 IP 地址绑定写死），没找到则发起一个迭代 DNS 解析请求  LDNS 向 根域名服务器 发起请求，RDNS 返回 一级域名 对应的 IP 地址 LDNS 向 一级域名服务器 发起请求，得到 二级域名 对应的 IP 地址 LDNS 向 二级域名服务器 发起请求，得到 三级域名 对应的 IP 地址   LDNS 将得到的 IP 地址返回给 OS，并且将这个 IP 地址缓存起来 OS 将 IP 地址返回给浏览器，并且将这个 IP 地址缓存起来 浏览器得到域名对应的 IP 地址，并且将这个 IP 地址缓存起来    建立 TCP 连接\n 三次握手  第一次：浏览器 向 服务器 发送一个SYN 报文，表示请求建立连接，此时处于 SYN_SENT 状态 第二次：服务器 得到 SYN 报文，回应一个 SYN + ACK 报文，此时处于 SYN_REVD 状态 第三次：浏览器 收到 SYN + ACK 报文，回应一个 ACK 报文，处于 ESTABLISHED 状态 服务器收到 ACK 报文后，也处于 ESTABLISHED 状态 三次握手的目的是为了确认双方的 接受能力 和 发送能力是否正常   如果是 HTTPS 协议，三次握手过程还会进行数字证书验证以及加密密匙的生成  浏览器发送一个 ClientHello 消息到服务器，消息中包含了它的 TLS（Transport Layer Security）版本，可用的加密算法和压缩算法 服务端向浏览器返回一个 ServerHello 消息，消息中包含了服务端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（CA）签发的服务器公开证书，证书中包含了钥，浏览器会使用这个公钥加密接下来的握手过程，直到协商生成新的对称密匙 浏览器根据自己信任的 CA 列表，验证服务器的证书是否可信，若是可信，浏览器会生成一串伪随机数，使用服务器的公钥加密他，这串随机数被用于生成新的对称密钥 服务端使用自己的私钥解密上面的随机数，然后使用这串随机数生成自己的对称主密钥 浏览器发送一个 Finished 消息给服务端，使用对称密钥加密这次通讯的一个散列值 服务端生成自己的 hash 值，然后解密客户端发送来的消息，检查这两个值是否对应，如果对应，就向浏览器发送一个 Finished 消息，并使用协商好的对称密钥加密 至此，接下来整个会话都是用对称密钥加密，传输内容      发送请求与接收响应\n 浏览器 向 服务器 发起一个 http-get 请求，请求中包含 URL、连接方式、User-Agent、cookie等信息  缓存具体行为在文章底部 服务器接收请求  鉴权，判断用户是否可以访问该资源 将对应的 HTML 文件返回给浏览器 若是后端架构为：代理服务器-服务器集群，则会先通过代理服务器进行端口转发、负载均衡等一系列动作，目的是为了降低服务器压力。      解析 HTML \u0026amp; 页面渲染\n 解析：HTML、CSS、JS  从浏览器进程的角度出发  浏览器进程有以下：  Browser 进程：浏览器的主进程，负责主控，协调，只有一个  负责下载页面的网络文件 负责将 render 进程得到的存在内存中的位图渲染到页面上 负责创建和销毁 tab 进程 负责与用户交互   GPU 进程：只有一个  负责 3D 绘制，只有当页面使用了硬件加速才会使用他，来渲染页面，否则不是用这个进程，而是用 Browser 进程来渲染页面   render 进程：又叫做浏览器内核，每个 tab 页面对应一个独立的 render 进程，内部有多个线程  render 进程是多线程的，例如：  JS 引擎线程：  也叫 JS内核，解析 JS 脚本，执行代码 与 GUI 线程互斥，当 JS 引擎线程运行时，GUI 线程会被挂起，直到 JS 引擎线程结束运行，才会继续运行 GUI 线程 有一个主线程和多个 web worker 线程组成，由于 web worker 是附属于主线程，无法操作 dom 等，所以 JS 还是单线程语言（在主线程运行）   GUI 渲染线程  用户解析 HTML 为 DOM 树，解析 CSS 为 CSSOM 树，布局 layout，绘制 paint 当页面需要 重排 reflow，重绘 repaint 时，使用该线程 于 JS 引擎线程互斥   事件触发线程  当对应事件触发（不论是 WebAPIs 完成事件触发，还是页面交互事件触发）时，该线程会将事件对应的回调函数放入 callback queue（任务队列）中，等待 JS 引擎线程处理。   定时触发线程  对应 setTimeout，setInterval，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中 当 setTimeout 的定时小于 4ms，一律按 4ms 计算   http 请求线程  每由一个 http 请求就开一个该线程 当检测到状态变更时，就会产生一个状态变更事件，如果该状态变更事件有对应回调函数的话，则放入任务队列中 任务队列轮询线程 用于轮询监听任务队列，以知道任务队列是否为空           在解析过程中，可能会请求图片、外部 CSS、JS 文件，会开启一个 http 线程，建立 TCP 连接，发送请求与接收响应 解析的过程可能会反复很多次，因为 JS 可能会修改 DOM 解析 HTML 生成 DOM 树 解析 CSS 生成 CSS 树 调用 render 进程的 GUI 线程 来解析 HTML 和 CSS 为 DOM 树和 CSSOM 树 解析 HTML 时，遇到 script 标签，先判断是内嵌代码还是外部JS文件，内嵌代码直接开启 JS 引擎线程，挂起 GUI 线程，执行 JS 代码，如果是外部 JS 文件，将会开启 http 线程下载 JS 文件并执行   渲染：构建 样式树 -\u0026gt; 渲染 -\u0026gt; 布局 -\u0026gt; 绘制  根据 CSS 树和 DOM 树 来创建 渲染树 渲染树完成后进行布局处理，确定每个节点在屏幕上的显示位置。 绘制      断开连接\n 四次挥手  第一次：浏览器 向 服务器发送一个 FIN 报文，处于 FIN_WAIT_1 状态 第二次：服务器收到 FIN 报文后，发送 ACK 报文给浏览器，表示已经收到浏览器的报文，此时处于 CLOSE_WAIT 状态 第三次：若此时服务器也想断开连接，和浏览器第一次挥手一样，发送一个 FIN 报文，此时处于 LAST_ACK 状态 第四次：浏览器收到 FIN 之后，发送一个 ACK 报文作为应答，此时客户端处于 TIME_WAIT 状态，等待一段时间确保服务器收到自己的 ACK 报文后进入 CLOSED 状态 服务器收到 ACK 报文后，就会断开连接，处于 CLOSED 状态         浏览器缓存分类：\n 强缓存 协议缓存    浏览器在加载资源时，会根据 request header 中的 expires 和 cache-control 判断是否命中强缓存\n  如果没有命中强缓存，client 将会向 server 发送请求，通过 last-modified 和 etag 验证资源是否命中协议缓存，若命中协议缓存，server 将会返回请求，但不会返回任何数据，资源依旧从缓存中读取\n  相同点\n 如果命中，都是从 client 加载资源，不从服务器加载    不同点\n 强缓存不发请求，协议缓存发送请求    强缓存\n 通过 Expires 和 Cache-Control 两种 request header 实现 Expires  Expires 表示资源过期时间，是一个绝对时间，由服务器返回。Expires 通过本地时间判断，也就是说，如果修改了本地时间，可能会造成缓存失效或者无法得到更新的资源   Cacha-Control  publi 表示资源可以被任何对象缓存，比如：client、代理服务器 private 表示只能被单个用户换粗，不可共享缓存，即代理服务器不可缓存 no-cache 表示发布缓存副本之前，强制要求原始服务器校验缓存 no-store 表示不缓存 max-age 表示缓存存储的最大周期，超过此时间就认为缓存过期，这个时间是相对时间 优先级高于 Expires      协议缓存\n 当强缓存没有命中时，就会发送请求到服务器，验证协议缓存是否命中，如果协议缓存命中，请求响应返回的 http 状态码为 304，并且会显示 Not Modified 协议缓存通过 Last-Modified、If-Modified-Since 和 ETag、If-None-Match 这两对 Header 来管理的 Last-Modified、If-Modified-Since  Last-Modified 表示本地文件最后修改日期，浏览器会在 request header 加上 If-Modified-Since （上次返回的 Last-Modified 的值），询问服务器在该日期后资源是否更新，有更新的话就会返回新资源   ETag、If-None-Match  Etag 描述了资源的信息摘要值，如果资源发生了变化，那么 Etag 的值也会变化，跟修改时间无关，Etag 保证每个资源都是唯一。 If-None-Match 会将上次的 Etag 发送给服务器，服务器将 两次 Etag 值进行对比，若是不相同，则返回新的资源 Etag 优先级高于 Last-Modified       待补充：\n CSS GPU 加速 客户端含有 Service Worker 的缓存情况   参考 what-happens-when-zh_CN、缓存（二）——浏览器缓存机制：强缓存、协商缓存\n","date":"Nov 18","permalink":"https://zinkwu.blog/articles/what-happens-when-you-type-an-url-in-the-browser-and-press-ente/","tags":null,"title":"浏览器地址栏输入URL敲回车之后发生了哪些事"},{"categories":null,"contents":"   \u0026lt;code\u0026gt;call\u0026lt;/code\u0026gt; \u0026amp;amp;\u0026amp;amp; \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; \u0026amp;amp;\u0026amp;amp; \u0026lt;code\u0026gt;bind\u0026lt;/code\u0026gt; 的作用  call、apply、bind的作用都是改变函数的 this 指向\n call：call 的第一个参数就是对函数绑定的 this，为一个对象，后面的参数是函数调用时所需要的参数 apply：apply 只接受两个参数，第一个与 call 相同，第二个参数是为数组，内容是函数调用所需要的参数 bind：bind 与 call作用相同，不过 bind 会返回一个新的函数，第一个参数之后的参数将绑定原函数的参数。     实现 \u0026lt;code\u0026gt;call\u0026lt;/code\u0026gt;  先来看看原生call的使用方法\n1 2 3 4 5 6 7 8 9 10 11  let obj = { a: 1 } function fn(){ console.log(this.a) } fn() // undefined  fn.call(obj) // 1   call 是如何将 this 绑定到 obj 上的呢？ 我们换一种思路，先看下面的代码\n1 2 3 4 5 6 7 8  let obj = { a: 1, fn(){ console.log(this.a) } } obj.fn() // 1   这段代码大家都能理解对吧，接下来，让我们打开脑洞。\n如果 call 只是将调用函数绑定到了第一个参数身上呢？似乎一切就说得通了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function fn(){ console.log(this.a) } Function.prototype.myCall = function(context){ context = context || window //首先判断是否传入第一个参数，如果没传，那么 this 就默认绑定到 window  context.callFn = this let result = context.callFn() delete context.callFn return result } let obj = { a: 1 } fn.myCall(obj) // 1   ok，初步绑定 this 的工作我们已经完成，接下来思考如何将剩下的参数传给调用函数。\n在函数中，我们不光可以访问 this 还可以访问 arguments 这个属性，他是一个类数组，内容就是传递给函数的参数，于是与，获取参数的问题也解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  function fn(val1,val2){ console.log(this.a) console.log(\u0026#39;val: \u0026#39;, val1, val2) } Function.prototype.myCall = function(context){ context = context || window let args = [] // ES5 的方法  for(let i = 1; i\u0026lt;arguments.length; i++){ args.push(arguments[i]) } /* * ES6的方法 * args = [...arguments].slice(1) * * 这个做法不推荐，在实现 cal l的方法中使用 call，有点本末倒置了 * args = Array.prototype.silce.call(arguments, 1) */ context.callFn = this // ES5 的做法，eval 接收一个字符串，将字符串作为 JS 代码执行  // 字符串模板会将数组变量展开  let result = eval(`context.callFn(${args})`) /* * ES6 的做法 * let result = context.callFn(...args) */ delete context.callFn return result } let obj = { a: 1 } fn.myCall(obj, 66,11) // 1, val: 61, 11      实现 \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt;  基本思路跟 call 是一样的，只不过需要注意，apply的第二个参数是数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function fn(val,val2){ console.log(this.a) console.log(\u0026#39;val\u0026#39;, val, val2) } Function.prototype.myApply = function(context){ context = context || window let args = arguments[1] context.applyFn = this let result = eval(`context.applyFn(${args})`) delete context.applyFn return result } let obj = { a: 1 } fn.myApply(obj, [66,11])      实现 \u0026lt;code\u0026gt;bind\u0026lt;/code\u0026gt;  bind 跟 call 的区别就在于 bind 会返回一个绑定 this 的新函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function fn(val,val2){ console.log(this.a) console.log(\u0026#39;val\u0026#39;, val, val2) } Function.prototype.myBind = function(context){ // 这里直接使用我们自己实现的 call 函数  let args = Array.prototype.slice.myCall(arguments); // ES5 的写法 // let me = this; // return function () { // return me.myApply(context, args.slice(1)) // }  return () =\u0026gt; { // 使用已经实现的 apply 函数来绑定 this 并且 return 这个函数  this.myApply(context, args.slice(1)) } } let obj = { a: 1 } fn.myBind(obj, 66,11)   ","date":"Sep 24","permalink":"https://zinkwu.blog/articles/call-apply-bind-implement/","tags":["JavaScript"],"title":"Call \u0026 Apply \u0026 Bind实现"},{"categories":null,"contents":"   防抖  函数防抖和节流，都是控制事件触发频率的方法。具体实现可以看我的这篇文章\n   input 如何处理中文输入  如果只是单纯的使用 input 事件来监听 input 值的改变，那么每次敲击键盘，输入一个字母都会触发 input 事件，其实我们想要的是获取用户输入的中文再进行后续操作。\n我们可以假象一下，输入中文时的字母都是预输入，只有当选择候选词之后，input得到的值才是我们想要的。\n现在，向大家介绍两个新的 DOM 事件：compositionstart、compositionend\n compositionstart：compositionstart 事件触发于一段文字的输入之前 compositionend：当文本段落的组成完成或取消时, compositionend 事件将被触发  1  \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  let inputElement = document.querySelector(\u0026#39;input\u0026#39;) let canRun = true inputElement.addEventListener(\u0026#39;compositionstart\u0026#39;, function(){ console.log(\u0026#39;start\u0026#39;) canRun = false }) inputElement.addEventListener(\u0026#39;compositionend\u0026#39;, function(){ console.log(\u0026#39;end\u0026#39;) canRun = true }) inputElement.addEventListener(\u0026#39;input\u0026#39;, debounce(fn)) function debounce(fn) { let timer = null; return function() { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { fn.apply(this, arguments) }, 500) }; } function fn(e){ if(canRun){ console.log(e.target.value) } }   当我们切换到中文输入法输入时开始在 input 中输入时，compositionstart 的回调函数被调用，将 canRun 状态切换为 false，半秒后执行 fn 时，canRun 状态为 false，不进行任何操作，当中文输入结束后，compositionend 的回调函数被调用，将 canRun 变为 true，此时 input 的回调函数调用，就可以执行后续的操作了，其实就是利用了 compositionstart 和 compositionend 来切换状态机的状态\n","date":"Sep 23","permalink":"https://zinkwu.blog/articles/chinese-input-debounce/","tags":["JavaScript"],"title":"Input中如何处理中文输入防抖"},{"categories":null,"contents":"   迫于  迫于在写 React 事件处理中的 this 时，写到 this 突然卡壳了，一顿冷静分析之后发现自己对于 this 的理解又忘了一些，于是痛定思痛，重新读了 《You-Dont-Know-JS》中关于 this 的文章。\n    函数的执行环境  首先上一段代码\n1 2 3 4 5 6 7 8 9 10 11 12  function fn(){ console.log(this.a) } let obj = { a: 1, fn: fn } var a = \u0026#39;window\u0026#39; fn() //window obj.fn() //1   首先我们要明确一点 ，this 不是编写代码时就绑定的，而是运行时绑定的。 比如 fn() 在调用时，所处的环境是 global，所以他的 this 就是 window 而 obj.fn() 在调用时，所处的环境是在对象 obj 内，所以他的 this 指向 obj 对象\n 当一个函数被调用时，会建立一个称为执行环境的活动记录。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是 如何 被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。\n 所以，this是根据调用点（函数如何被调用）来为每次函数调用建立的绑定\n    调用点的规则    默认绑定： 首先是独立函数调用。在这种倾向下，this 规则是在没有其他规则适用时的默认规则。\n1 2 3 4 5  function fn(){ console.log(this) } fn() //window   fn() 被独立调用，此时的 this 是默认绑定，所以 this 指向了 window\n  隐含绑定 这种规则是：调用点是否拥有一个对象环境。\n1 2 3 4 5 6 7 8 9 10  function fn(){ console.log(this.a) } let obj = { a: 1, fn: fn } obj.fn() //1   首先，fn被声明然后作为引用属性添加到 obj 上，我们知道，对象、函数、数组等都是引用类型，存在于堆内存中，以传值（地址）的方式被变量引 用，所以 obj 并不包含或者拥有函数 fn\nobj.fn() 的调用点以 obj 环境来引用函数，所以，函数在被调用的时间节点上拥有对象环境 obj\n对象属性引用链的最后一层是影响调用点的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function fn() { console.log( this.a ); } let obj2 = { a: 42, fn: fn }; let obj1 = { a: 2, obj2: obj2 }; obj1.obj2.fn(); // 42     隐含丢失 隐含丢失：隐含绑定丢失了他的绑定，如何丢的？看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function fn(){ console.log(this.a) } let obj = { a: 1, fn: fn } let foo = obj.fn var a = \u0026#39;window\u0026#39; foo() //window   这段代码，将 foo 引用了 obj.fn，但是在 foo()，他依然属于函数独立调用，所以 this 指向全局作用域的 a\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function fn(){ console.log(this.a) } function bar(f){ f() } let obj = { a: 1, fn: fn } var a = \u0026#39;window\u0026#39; bar(obj.fn) // window   这段代码中，将 obj.fn 作为回调函数传入 bar 中，但是 bar 调用回调函数的方式依然属于 函数独立调用，所以 this 指向 全局作用域的 a\n1 2 3 4 5 6 7 8 9 10 11 12  function fn(){ console.log(this.a) } let obj = { a: 1, fn: fn } var a = \u0026#39;window\u0026#39; setTimeout(obj.fn, 1000) // window   这段代码跟上一段一样。\n  箭头函数 箭头函数的 this 不是在运行时生效的，而是在定义这个箭头函数时生效的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let obj = { fn(){ setTimeout(function(){ console.log(this) }, 1000) }, arrow(){ let a = () =\u0026gt; {console.log(this)} setTimeout( a, 1000) } } obj.fn() //window obj.arrow() //对象obj   obj.fn 中 setTimeout 中的回调函数相当于函数独立调用，this 指向 window，obj.arrow 中的 setTimeout 中的回调函数是一个 箭头函数，而箭头函数的 this 时函数定义生效时所在的对象，也就是 obj，arrow 中的 a 引用了箭头函数，而这个箭头函数是在 arrow 执行时定义的，所以所指向的对象环境为 obj。\n  ","date":"Sep 16","permalink":"https://zinkwu.blog/articles/about-this/","tags":["JavaScript"],"title":"这一次，我一定会搞定 This ！"},{"categories":null,"contents":"   什么是防抖？如何实现？  动作绑定事件，动作发生后一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。\n实现：每次触发事件时都取消之前的延时调用方法。\n1 2 3 4 5 6 7 8 9  function debounce(fn) { let timer = null; return function() { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { fn.apply(this, arguments) }, 500) }; }       什么是节流？如何实现？  动作发生后一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新触发。\n实现：每次触发事件时都判断当前是否有等待执行的延时函数，如果有，则无视该次动作。\n1 2 3 4 5 6 7 8 9 10 11  function throttle(fn) { let canRun = true; return function() { if (!canRun) return; canRun = false; setTimeout(() =\u0026gt; { fn.apply(this, arguments); canRun = true; }, 500); }; }       区别  防抖和节流的区别在于：\n 防抖的思路是：指定事件触发的函数在一定时间后执行，如果在这段时间内再次触发该事件，那么便取消上一次的执行。 节流的思路是：指定事件触发的函数在一定时间后执行，如果在这段时间内再次触发该事件，那么便无视该次事件动作。  ","date":"Aug 06","permalink":"https://zinkwu.blog/articles/debounce-throttle/","tags":["JavaScript"],"title":"防抖和节流"},{"categories":null,"contents":"   JavaScript的数据类型  JS中有7种数据类型：String、Number、Boolean、Null、Undefined、对象以及ES6新增的Symbol。 由于目前还未深入了解过Symbol，所以此次不讨论Symbol。 其中6种为基本类型（或叫做简单数据类型）和1种引用类型（复杂数据类型）。\n 基本类型  String Number Boolean Null Undefined   引用类型  对象       不同数据类型在内存中如何存储？  我们将内存分为栈（Stack）内存和堆（Heap）内存 基本类型以固定大小的空间存在与栈内存中，当基本类型发生值的拷贝时，目标变量会得到原始变量的值的副本。\n1 2  let a = 1 let b = a //1   引用类型的值是对象，保存在堆内存中，引用类型的变量的值并不是值的本身，而是这个值在堆内存中的地址（也有说法为指针，不过我个人觉得地址容易理解）。当引用类型发生值的拷贝的时候，实际上目标变量得到的是原始变量的值的地址。\n1 2 3 4 5 6 7  let obj1 = { name: \u0026#34;jack\u0026#34; } /* 此时{name: \u0026#34;jack\u0026#34;}这个对象存在于堆内存中，我们假设他的地址是218 */ let obj2 = obj1 //在这个赋值操作中，传递的其实是对象在内存中的地址      浅拷贝  1 2 3 4 5 6 7 8 9 10  let data = { name: \u0026#34;jack\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34; } let copyDate = data copyDate === data //true copyDate.name = \u0026#34;Tom\u0026#34; copyDate.name === data.name //true copyDate === data //true   上面这段代码就是一个浅拷贝的例子，由此可见，浅拷贝就是目标变量得到原始变量的值后， 不管是目标变量还是原是变量，只要值发生变化，那么两个变量都会收到影响。这一点从内存图中就可以看出，因为引用地址相同。\n   深拷贝  1 2 3 4  let a = 1 let b = a b = 2 a //1   变量b得到变量a的值，但变量b的值改变，不影响变量a，这就是深拷贝\n   存在的问题 \u0026amp;amp; 解决方法  有些时候，我们需要深拷贝一个对象或者数组，但=操作符只能实现浅拷贝\n对象的深拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //最容易想到的方法：遍历原始对象 let obj = { name: \u0026#34;jack\u0026#34; } let copyObj = {} for(let key in obj){ copyObj[key] = obj[key] } obj === copyObj //false //使用JSON let a = {name: \u0026#34;alex\u0026#34;} let b = JSON.parse(JSON.stringify(a)) //ES6的方法 let source = { name: \u0026#34;Tom\u0026#34;, age: 18 } let target = Object.assign({}, source) //Object.assign方法用于将原始对象的所有可枚举属性复制到目标对象上。 target === source //false   数组的深拷贝\n1 2 3 4 5 6 7  //最简单的方法还是遍历数组，这里就不多讲 //其次我们可以用到Array的方法，比如map、slice等可以返回新数组的方法 let a = [1,2,3,4] let b = a.map(n =\u0026gt; n) let c = a.slice() a === b || a === c //false   ","date":"Jul 24","permalink":"https://zinkwu.blog/articles/js-deep-and-shallow-clone/","tags":["JavaScript"],"title":"JavaScript的深浅拷贝"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://zinkwu.blog/articles/","tags":null,"title":"Articles"}]